<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta name="author" content="NaTie"/><meta name="copyright" content="NaTie"/><meta name="theme-color" content="#FFB347"/><meta name="format-detection" content="telephone=no"/><meta name="keywords" content="数据结构"/><meta name="mobile-web-app-capable" content="yes"/><meta name="apple-mobile-web-app-capable" content="yes"/><meta name="apple-touch-fullscreen" content="yes"/><meta name="application-name" content="计算机问题 | NaTie 's Hexo"/><meta name="apple-mobile-web-app-title" content="计算机问题 | NaTie 's Hexo"/><meta name="apple-mobile-web-app-status-bar-style" content="#FFB347"/><link rel="canonical" href="http://example.com/2025/10/28/计算机问题/"/><meta name="description" content="数据结构绪论 时间复杂度（注意，除了一眼看出时间复杂度，还要能够推导出来时间复杂度，多做做题，甚至还会牵扯到平均时间复杂度） 平均时间复杂度  1234567要理解顺序表插入的平均时间复杂度，我们可以从 “概率”“移动次数”“求和公式” 三个维度逐步拆解，保证通俗且严谨：第一步：明确 “时间复杂度的核心是‘移动元素的次数’”顺序表插入时，元素后移的次数决定了时间消耗。比如插入到表头（i&#x3D;1）...">
<meta property="og:type" content="article">
<meta property="og:title" content="计算机问题 | NaTie &#39;s Hexo">
<meta property="og:url" content="http://example.com/2025/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="NaTie &#39;s Hexo">
<meta property="og:description" content="数据结构绪论 时间复杂度（注意，除了一眼看出时间复杂度，还要能够推导出来时间复杂度，多做做题，甚至还会牵扯到平均时间复杂度） 平均时间复杂度  1234567要理解顺序表插入的平均时间复杂度，我们可以从 “概率”“移动次数”“求和公式” 三个维度逐步拆解，保证通俗且严谨：第一步：明确 “时间复杂度的核心是‘移动元素的次数’”顺序表插入时，元素后移的次数决定了时间消耗。比如插入到表头（i&#x3D;1）...">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2025/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%97%AE%E9%A2%98/assets/images/Hexo-Theme-MEOW.png">
<meta property="article:published_time" content="2025-10-28T20:01:47.000Z">
<meta property="article:modified_time" content="2026-01-29T09:04:38.177Z">
<meta property="article:author" content="NaTie">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2025/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%97%AE%E9%A2%98/assets/images/Hexo-Theme-MEOW.png"><meta name="robots" content="index,follow"/><meta name="googlebot" content="index,follow"/><meta name="revisit-after" content="1 days"/><title>计算机问题 | NaTie 's Hexo</title><link rel="shortcut icon" href="/assets/images/Hexo-Theme-MEOW.ico"><link rel="preconnect" href="/assets"/><link rel="preconnect" href="assets"/>
<link rel="stylesheet" href="/css/style.css">

<link rel="stylesheet" href="/css/third-party/dist/snackbar.min.css">
<link rel="prefetch" href="/"/><link rel="prefetch" href="/archives"/><link rel="prefetch" href="/tags"/><meta name="generator" content="Hexo 7.3.0"></head><body bg-style="none"><header><div id="navbar"><div id="nav-info"><a id="site-icon" href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a id="site-name" href="/" title="主页"><div>NaTie 's Hexo</div><img src="/assets/images/svg/uc/uc-home.svg" class="icon noview" alt="Icon"></a></div><div id="nav-menu"></div><div id="nav-function"><div id="search-btn"><a href="javascript:void(0);" title="搜索" accesskey="s"><img src="/assets/images/svg/uc/uc-search.svg" class="icon noview" alt="Icon"><span>搜索</span></a></div><div id="menu-btn"><a href="javascript:void(0);" title="打开菜单"><img src="/assets/images/svg/uc/uc-menu.svg" class="icon noview" alt="Icon"></a></div></div></div></header><div id="menu-aside"><div id="menu-aside-container"><div id="menu-aside-info"><a href="/" title="主页"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></a><a href="/" title="主页">NaTie 's Hexo</a></div><hr/></div></div><main><div class="banner"><div class="banner-info"><div class="banner-avatar"><img src="/assets/images/Hexo-Theme-MEOW.png" alt="Avatar"/></div><div class="banner-title">「 My Honor 」</div></div></div><div class="post-container"><div class="post-main"><div class="post-content"><h1 class="post-title">计算机问题</h1><div class="post-author"><span>作者: NaTie</span></div><div class="post-meta"><div class="post-info"><div class="post-date"><div class="post-pubdate"><img src="/assets/images/svg/ta/ta-pubdate.svg" class="icon noview" alt="Icon"><span>发表于2025-10-28</span></div><div class="post-update"><img src="/assets/images/svg/ta/ta-update.svg" class="icon noview" alt="Icon"><span>更新于2026-01-29</span></div></div><div class="post-read"><div class="post-wordcount"><img src="/assets/images/svg/ta/ta-write.svg" class="icon noview" alt="Icon"><span>总字数: 8.5k字</span></div><div class="post-readtime"><img src="/assets/images/svg/ta/ta-time.svg" class="icon noview" alt="Icon"><span>阅读时长: 26分钟</span></div><div class="post-pageview"><img src="/assets/images/svg/ta/ta-fire.svg" class="icon noview" alt="Icon"><span>访问量: </span><span id="vercount_value_page_pv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div></div></div><div class="post-attribute"><div class="post-categories"><img src="/assets/images/svg/ta/ta-category.svg" class="icon noview" alt="Icon"><span><a class="post-categories-link" href="/categories/%E8%80%83%E7%A0%94%E7%AC%94%E8%AE%B0/">考研笔记</a></span></div><div class="post-tags"><img src="/assets/images/svg/ta/ta-tag.svg" class="icon noview" alt="Icon"><span><a class="post-tags-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></span></div></div></div><div class="post markdown" indent="false"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><ol>
<li>时间复杂度（注意，除了一眼看出时间复杂度，还要能够推导出来时间复杂度，多做做题，甚至还会牵扯到平均时间复杂度）</li>
<li>平均时间复杂度</li>
</ol>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">要理解顺序表插入的平均时间复杂度，我们可以从 “概率”“移动次数”“求和公式” 三个维度逐步拆解，保证通俗且严谨：</span><br><span class="line">第一步：明确 “时间复杂度的核心是‘移动元素的次数’”</span><br><span class="line">顺序表插入时，元素后移的次数决定了时间消耗。比如插入到表头（i=1），需要移动 n 个元素；插入到表尾（i=n+1），不需要移动元素。</span><br><span class="line">第二步：理解 “平均” 的含义 —— 所有情况的 “移动次数 × 概率” 之和</span><br><span class="line"></span><br><span class="line">假设在长度为 n 的顺序表中插入元素，插入位置`i`的可能范围是`1 ≤ i ≤ n+1`（共`n+1`个位置）。</span><br><span class="line">题目中假设 “每个位置插入的概率相等”，即每个位置`i`的插入概率</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<p> $p_i &#x3D; \frac{1}{n+1}$</p>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对于每个位置`i`，插入时需要移动的元素个数是 (n - i + 1)（比如`i=1`时，移动`n`个；`i=2`时，移动`n-1`个…`i=n+1`时，移动`0`个）。</span><br><span class="line"></span><br><span class="line">因此，平均移动次数 = 所有位置的 “移动次数 × 该位置的概率” 之和，公式表示为：</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<p>$\text{平均移动次数} &#x3D; \sum_{i&#x3D;1}^{n+1} p_i \times (n - i + 1)$</p>
<ol start="3">
<li>空间复杂度问题(与额外空间有关，而不是本身的数据内存，比如处理这个问题，你开了个新数组，栈空间等)</li>
</ol>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 5; // 输入数据（不算额外） </span><br><span class="line">int b = 10; // 输入数据（不算额外） </span><br><span class="line">int temp = a; // 算法新创建的临时变量（额外空间） </span><br><span class="line">a = b; b = temp;</span><br><span class="line"></span><br><span class="line">//无论a和b多大，a=1000，或者10000,算法都只创建了一个变量temp，额外空间就是1个格子    O（1）</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int[] oldArr = &#123;1,2,3,...,n&#125;; // 输入数据（不算额外） int[] newArr = new int[n]; // 算法新创建的数组（额外空间，长度n） for (int i=0; i&lt;n; i++) &#123; newArr[i] = oldArr[i]; &#125;</span><br><span class="line"></span><br><span class="line">//新数组`newArr`的长度是`n`，`n`越大（比如`n=100`变成`n=1000`），这个数组占的内存就越大，且和`n`成正比。所以空间复杂度：`O(n)`。</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int n = 5; // 问题规模 </span><br><span class="line">int[][] table = new int[n][n]; // 新创建的二维数组（额外空间，n×n个元素） for (int i=0; i&lt;n; i++) &#123;</span><br><span class="line"> for (int j=0; j&lt;n; j++)&#123;</span><br><span class="line">  table[i][j] = i * j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//二维数组table有n×n个元素，n=5时是 25 个，n=10时是 100 个，和n²成正比。 所以空间复杂度：O(n²)。</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n) &#123; if (n &lt;= 1) return n; return fib(n-1) + fib(n-2); // 递归调用 &#125;</span><br><span class="line"></span><br><span class="line">//特殊例子递归函数运行时，每次调用都会在 “调用栈” 里保存一些信息（比如参数、返回地址），这些栈空间也算 “额外空间”。计算`fib(5)`时，调用顺序是：`fib(5) → fib(4) → fib(3) → fib(2) → fib(1)`，栈里最多同时保存 5 个调用的信息（深度为`n`）。所以额外空间和`n`成正比，空间复杂度：`O(n)`。</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><ol>
<li>区分逻辑结构和存储结构，线性表是逻辑结构，顺序表表示顺序存储，是存储结构，链表是链式存储，是存储结构</li>
<li>顺序表</li>
</ol>
<ul>
<li>随机存取（Random Access）的核心是：<strong>能通过地址直接访问任意位置的元素，访问时间与元素的位置无关</strong>。</li>
<li>空间分配<br>静态分配</li>
</ul>
<div class="code-container" code-lang="C"><div class="codebox"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int <span class="comment">// 元素类型 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100 <span class="comment">// 固定容量（C用#define） </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> </span><br><span class="line">ElemType data[MaxSize];<span class="comment">// 固定数组存数据 </span></span><br><span class="line"><span class="type">int</span> length; <span class="comment">// 当前长度 </span></span><br><span class="line">&#125; SeqListStatic; <span class="comment">// 初始化（C）</span></span><br><span class="line">SeqListStatic L_static; L_static.length = <span class="number">0</span>; <span class="comment">// 长度置0</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* C++写法差异： </span></span><br><span class="line"><span class="comment"> const int MaxSize = 100; // C++用const替代#define struct SeqListStatic &#123; // 可省略typedef ElemType data[MaxSize]; </span></span><br><span class="line"><span class="comment"> int length; &#125;; </span></span><br><span class="line"><span class="comment"> SeqListStatic L_static; </span></span><br><span class="line"><span class="comment"> L_static.length = 0; */</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<p>动态分配</p>
<div class="code-container" code-lang="C"><div class="codebox"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C语言</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> InitSize 100       <span class="comment">// 初始容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    ElemType *data;        <span class="comment">// 指针指向动态数组</span></span><br><span class="line">    <span class="type">int</span> length;            <span class="comment">// 当前长度</span></span><br><span class="line">    <span class="type">int</span> MaxSize;           <span class="comment">// 当前最大容量</span></span><br><span class="line">&#125; SeqListDynamic;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化（C）</span></span><br><span class="line">SeqListDynamic L_dynamic;</span><br><span class="line">L_dynamic.data = (ElemType*)<span class="built_in">malloc</span>(InitSize * <span class="keyword">sizeof</span>(ElemType));<span class="comment">// 分配初始空间</span></span><br><span class="line">L_dynamic.length = <span class="number">0</span>;</span><br><span class="line">L_dynamic.MaxSize = InitSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩容核心（C）</span></span><br><span class="line"><span class="type">int</span> newSize = <span class="number">200</span>;</span><br><span class="line">ElemType *p = L_dynamic.data;</span><br><span class="line">L_dynamic.data = (ElemType*)<span class="built_in">malloc</span>(newSize * <span class="keyword">sizeof</span>(ElemType));<span class="comment">// 新空间</span></span><br><span class="line">L_dynamic.MaxSize = newSize;</span><br><span class="line"><span class="built_in">free</span>(p);                   <span class="comment">// 释放旧空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* C++写法差异：</span></span><br><span class="line"><span class="comment">const int InitSize = 100;</span></span><br><span class="line"><span class="comment">struct SeqListDynamic &#123;    // 省略typedef</span></span><br><span class="line"><span class="comment">    ElemType *data;</span></span><br><span class="line"><span class="comment">    int length;</span></span><br><span class="line"><span class="comment">    int MaxSize;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 初始化（C++）</span></span><br><span class="line"><span class="comment">SeqListDynamic L_dynamic;</span></span><br><span class="line"><span class="comment">L_dynamic.data = new ElemType[InitSize];// new替代malloc</span></span><br><span class="line"><span class="comment">L_dynamic.length = 0;</span></span><br><span class="line"><span class="comment">L_dynamic.MaxSize = InitSize;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 扩容（C++）</span></span><br><span class="line"><span class="comment">int newSize = 200;</span></span><br><span class="line"><span class="comment">ElemType *oldData = L_dynamic.data;</span></span><br><span class="line"><span class="comment">L_dynamic.data = new ElemType[newSize];// new分配新空间</span></span><br><span class="line"><span class="comment">L_dynamic.MaxSize = newSize;</span></span><br><span class="line"><span class="comment">delete[] oldData;          // delete[]替代free</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<ol start="3">
<li>链式表</li>
</ol>
<ul>
<li><strong>单链表(非随机存储)</strong></li>
</ul>
 <div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义单链表节点结构体 </span><br><span class="line">typedef struct LNode &#123; </span><br><span class="line"> ElemType data; // 数据域：存储节点数据（ElemType为元素类型，需提前定义） </span><br><span class="line"> struct LNode *next; // 指针域：指向后继节点（指向同类型结构体的指针） </span><br><span class="line">&#125; LNode, *LinkList; // 为结构体起别名：LNode（节点类型）、LinkList（节点指针类型）</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<p>LNode：是 <code>struct LNode</code> 结构体的<strong>类型别名</strong>，用于定义 “链表节点变量”（比如 <code>LNode node;</code> 就相当于 <code>struct LNode node;</code>）。<br><em>LinkList：是 <code>struct LNode *</code>（结构体指针）的*<em>类型别名</em></em>，用于定义 “链表头指针”（比如 <code>LinkList L</code> 就相当于 <code>struct LNode *L;</code>，表示指向链表头节点的指针）。</p>
<ul>
<li>注意区分带头节点和不带头结点的。链条顺序是，头指针指向头结点（不带信息或者带一些长度等附加信息），后续跟着实际的带信息的链条</li>
<li>带头结点的会更方便，但是也要看看题目要求</li>
<li>一般代码顺序：先定义节点，然后初始化，然后增删改查</li>
<li>写代码时候先确定一下是对整个链表操作，还是对链表中某个结点操作。函数是LNode * 还是用LinkList，虽然这俩完全等价，只是别名不同，表示不同含义。</li>
<li>采用头插法插入节点生成链表，最先插入的结点到最后越往后，所以插入顺序和读取顺序是反的</li>
<li>尾插法读取顺序和插入顺序是一致的</li>
<li><strong>双链表</strong></li>
</ul>
 <div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 定义双链表节点结构体 </span><br><span class="line">typedef struct DNode &#123; </span><br><span class="line"> ElemType data; // 数据域：存储节点数据（ElemType为元素类型，需提前定义） </span><br><span class="line"> struct DNode *prior,*next; // 前驱和后继指针，类型是struct DNode是因为后面还没有重命名，所以还不认识直接DNode，需要用struct DNode声明</span><br><span class="line">&#125; DNode, *DLinkList; </span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<ul>
<li>单链表只有一个指向后继的指针，双链表可以直接查看前驱和后继</li>
<li>表头节点的prior和尾节点的next为NULL</li>
<li>双链表的按值查找和按位查找与单链表相同，但是在插入和删除上有大的不同</li>
</ul>
 <div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//插入操作</span><br><span class="line">// 在双链表中p所指节点之后插入值为e的新节点 </span><br><span class="line">bool DListInsertAfter(DNode *p, ElemType e) &#123; </span><br><span class="line">if (p == NULL) &#123; // p为NULL，无法插入 </span><br><span class="line">return false; &#125;</span><br><span class="line"> DNode *s = (DNode *)malloc(sizeof(DNode)); // 创建新节点s </span><br><span class="line"> if (s == NULL) &#123; // 内存分配失败 </span><br><span class="line"> return false; &#125; </span><br><span class="line"> s-&gt;data = e; // 给新节点赋值</span><br><span class="line">  // 指针调整步骤（严格顺序：①→②→③→④）</span><br><span class="line">  s-&gt;next = p-&gt;next; // ① s的后继指向p的原后继 </span><br><span class="line">  if (p-&gt;next != NULL) &#123; // 若p原来有后继节点，调整其前驱 </span><br><span class="line">  p-&gt;next-&gt;prior = s; // ② p的原后继的前驱指向s </span><br><span class="line">  &#125; </span><br><span class="line">  s-&gt;prior = p; // ③ s的前驱指向p</span><br><span class="line">   p-&gt;next = s; // ④ p的后继指向s</span><br><span class="line">    return true; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<ul>
<li><strong>循环链表（为提高效率，后续内容只记录关键的，或者不会的点）</strong></li>
<li>对循环单链表，有时候可能不设头指针，而仅设置尾指针，因为如果设尾指针r，r-&gt;next就是头指针。循环单链表因为是个环，所以任何位置上插入和删除都是等价的，无需判断是否为表尾。判空条件也变为表尾节点* r-&gt;next是否等于头指针</li>
<li>循环双链表的头结点的prior指向表尾节点，尾节点的next指向头结点。当循环双链表为空时，头结点的prior和next都等于L</li>
<li><strong>静态链表</strong></li>
</ul>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 定义静态链表</span><br><span class="line">#define MaxSize 50</span><br><span class="line">typedef struct &#123; </span><br><span class="line"> ElemType data; </span><br><span class="line"> int next;  </span><br><span class="line">&#125; SLinkList[MaxSize]; </span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<p> 静态链表以next &#x3D;&#x3D; -1作为结束的标志</p>
<ul>
<li>注意顺序表个链表的比较</li>
<li>该章节代码量较少，所以刚好适合笔试考察，考代码时，用三段论作答</li>
</ul>
 <div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.给出算法基本设计思想</span><br><span class="line">2.采用C或C++语言描述算法，并给出注释</span><br><span class="line">3.分析所设计算法的时间复杂度和空间复杂度</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>

<h2 id="栈、队列、数组"><a href="#栈、队列、数组" class="headerlink" title="栈、队列、数组"></a>栈、队列、数组</h2><ul>
<li><strong>栈</strong></li>
<li>栈也是线性表</li>
<li>栈是后进先出</li>
<li>顺序栈的底层是数组 <code>data[MaxSize]</code>，数组的下标是<strong>从 <code>0</code> 开始</strong>的，因此它的有效下标范围是 <code>0 ~ MaxSize-1</code>（共 <code>MaxSize</code> 个位置）。所以判断栈满是s.top&#x3D;&#x3D; MaxSize-1,当top是从-1开始的时候。这种情况下是先top+1，在送值进去，但是如果不是-1，情况又不一样了。初始值从0开始，就是先送值在+1</li>
<li>顺序栈容易溢出</li>
<li>共享栈，两个栈共用一个空间，top0&#x3D;&#x3D; -1时左边栈为空，top1&#x3D;&#x3D; MaxSize 右边栈为空。两边同时朝对方靠近，当top1-top0&#x3D;1时，为栈满</li>
<li>栈链式存储中，要看看有没有带头结点</li>
<li><strong>队列</strong></li>
<li>先进先出</li>
<li>栈和队列是操作受限的线性表，但不是任何对线性表的操作都可以作为栈和队列处理，比如不可以随便读取栈和队列中间某个数据</li>
<li>队列的顺序存储</li>
<li>循环队列（不想记录，太多了，理解后多去看看，主要需要注意队空队满情况，以及区分队空还是队满的三种方式，还有就是入队出队需要取模）</li>
<li>队列的链式存储</li>
</ul>
<div class="code-container" code-lang="C"><div class="codebox"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式队列的节点结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;           <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span> *<span class="title">next</span>;</span>   <span class="comment">// 指针域，指向下一个节点</span></span><br><span class="line">&#125;LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式队列的结构体（包含队头、队尾指针）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    LinkNode *front,*rear;   <span class="comment">// 队头指针和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<ul>
<li>双端队列</li>
<li>多做几题熟悉一下，还有受限双端队列</li>
<li>栈和队列的应用</li>
<li>栈–括号匹配</li>
<li>栈–算数表达式（需要会中缀表达式转到后缀表达式的手算方式，其中后缀表达式进行求值用的是栈，要知道逻辑）</li>
<li>栈–递归</li>
<li>队列–层次遍历</li>
<li>计算机系统的应用（打印机缓冲区–队列，CPU资源争抢–队列）</li>
<li>数组和特殊矩阵(题目里可能会有，要做几道感受一下)</li>
<li>数组就是计算机数组的底层逻辑，其实就是一片空间，数组怎么一个个放进去，二维数组等，看起来是二维，实际上就是几个一组几个一组放进去的。但是要注意是按行优先还是按列优先</li>
<li>特殊矩阵就是线性代数里面一些特殊矩阵，压缩存储值得是多个值相同的元素只用一个存储空间。对0元素直接不分配空间。其实就是对称矩阵这种东西，可以只存一半数据而不是存一大堆。</li>
<li>需要注意的是，数组是从0开始的，但是矩阵是从$a_{11}$开始的</li>
<li>存储稀疏矩阵时，由于非零元素很少，且分布不均匀，所以要记录行列和值，而不光光是值。因此没有随机存取特性</li>
</ul>
<h2 id="串（算法在考研中不考）"><a href="#串（算法在考研中不考）" class="headerlink" title="串（算法在考研中不考）"></a>串（算法在考研中不考）</h2><ul>
<li>子串是主串任意多个连续的字符组成的</li>
<li>子串在主串中的位置以子串的第一个字符在主串中的位置来表示</li>
<li>串中字符的个数称为串的长度</li>
<li>当两个串长度相等且每个对应位置字符都相等时，这两个串相等。</li>
<li>例如，有串 A&#x3D;’China Beijing’，B&#x3D;’Beijing’，C&#x3D;’China’，则它们的长度分别为 13、7 和 5。B 和 C 是 A 的子串，B 在 A 中的位置是 7，C 在 A 中的位置是 1。</li>
<li>注意，由一个或多个空格（空格是特殊字符）组成的串称为空格串（空格串不是空串），其长度为串中空格字符的个数。</li>
<li>串的模式匹配要会算（简单模式匹配和KMP算法）</li>
<li>KMP算法，已匹配过的串里面有模式串前缀，可以不必再回溯，而是直接从能匹配的前缀对其，继续测。模式串滑动是便于理解，但实际上是指针，next数组（有些复杂要会手算）</li>
<li>知道怎么手算出next数组就行，不用代码。但是求出next数组以后要怎么用代码实现需要知道，还要知道它的时间复杂度</li>
<li>next[1] j一定为0，然后j和i都要++ </li>
<li>next[2] j一定为1，因为第二个位置匹配失败，主串的第二个位置要和模式串第一个位置匹配试试，模式串一定会是要后移一位的，i不变，j变成1</li>
<li>步骤是先确认next数组（和主串没关系，假设主串是一堆黑盒），然后next确认完成后进行实际匹配，哪一位对不上就去看刚才next数组，让j变成next[j]，i不变。除非第一位都匹配不上，j和i都只能后移。</li>
<li>kmp算法还能优化，因为有可能连续两次都匹配失败，但是你两次其实不用再验一次，有一次是浪费时间的行为，同一个j肯定还是匹配失败的，所以这里就可以就行优化。</li>
<li>kmp算法建议遇到题目的时候再去看看相关视频</li>
<li>实际上就是用nextval数组去替代next数组，代码逻辑不变，主要是要知道nextval数组要怎么弄出来</li>
<li>如果T.ch[j]&#x3D;&#x3D; T.ch[next[j]],nextval[j]就等于nextval[next[j]],相当于递归。如果不相等，就不影响，直接照抄next就行</li>
</ul>
<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><ul>
<li>n个节点，n-1条边</li>
<li>结点层次，根结点为第一层。结点的深度就是结点的层次。树的高度就是树的最大层次。结点的高度就是以该结点为根的树的高度。</li>
<li>结点的孩子数量叫做度，整棵树中最大的度为树的度</li>
<li>路径与路径长度，路径就是两个结点中间所有经过的结点序列。长度就是这些结点的边。且路径是从上往下的</li>
<li>森林和树概念，森林就是一堆树，这森林要是用一个根节点联系在一起，就又变成了树</li>
<li>树的一些性质要记住<ul>
<li>树的结点树是树的总度数+1</li>
<li>度为m的树，第i层最多有$m^{(i-1)}$个节点，第一层根节点只有一个，第二层最多m个，第三层最多$m^2$…..</li>
<li>高为h的m叉树至多有（$(m^k-1)&#x2F;(m-1)$）个结点。（用等比数列的公式计算）</li>
<li>结点固定，树的度确定，要求高度最小，那就是每一层都铺满。</li>
<li>度确定，总结点固定，高度要最大，就让某一个结点有m个孩子，其他都只有一个孩子</li>
</ul>
</li>
<li><strong>二叉树</strong></li>
<li>每个结点至多只有两棵子树</li>
<li>可以是空树，所以这一点要和度为2的树进行区别，度为2意味着至少有三个结点。</li>
<li>二叉树结点孩子是有顺序的，有序树如果只有一个孩子就无所谓左右，但是二叉树和度为2的有序数不一样，必须分左右</li>
<li><strong>满二叉树</strong></li>
<li>因为二叉树无论有没有孩子都要分左右，所以可以进行编号，知道某一结点编号i，要知道它的孩子和双亲结点编号怎么算出来</li>
<li><strong>完全二叉树</strong></li>
<li>满二叉树是全满，完全二叉树就是满二叉树缺最后几个节点，不允许中间缺。</li>
<li><strong>二叉排序树</strong></li>
<li>左子树所有结点关键字均小于根节点，右子树所有结点均大于根节点。</li>
<li><strong>平衡二叉树</strong></li>
<li>左右子树高度差绝对值不超过1</li>
<li><strong>正则二叉树</strong></li>
<li>树中只有度为0或2的结点</li>
<li><strong>二叉树性质</strong><ul>
<li><strong>非空二叉树叶节点数等于度为2的结点数+1，即$n_0&#x3D;n_2+1$</strong></li>
<li>非空二叉树第k层最多有$2^{k-1}$个结点</li>
<li>高度为h的二叉树至多有$2^h-1$</li>
<li>完全二叉树进行编号，从左到右编号是1,2，…，n<ul>
<li>最后一个分支结点$\lfloor n&#x2F;2 \rfloor$，若i&gt;$\lfloor n&#x2F;2 \rfloor$为叶结点，若i&lt;$\lfloor n&#x2F;2 \rfloor$为分支结点</li>
<li>叶结点只会出现在最后两层</li>
<li>若有度为1的结点，只可能有一个，且该结点只有左孩子没有右孩子</li>
<li>若n为奇数，则每个分支结点都有左右孩子。若n为偶数，编号最大的分支节点，n&#x2F;2只有左孩子没有右孩子。其余分支都有左右孩子</li>
<li>当i&gt;1,其双亲节点编号$\lfloor i&#x2F;2 \rfloor$</li>
<li>若结点i有孩子，左孩子为2i，右孩子为2i+1</li>
<li>结点i所在层次（深度）为${\lfloor log_2i \rfloor}+1$</li>
<li>具有n个（n&gt;0）结点的完全二叉树高度为h&#x3D;${\lceil log_2(n+1) \rceil}$，因为h是个正整数</li>
</ul>
</li>
</ul>
</li>
<li>由于树的性质，原本用顺序存储好，可以对应结点关系。但是会浪费很多空间，一味为了对应结点关系。所以一般还是用链式存储</li>
<li>一般结构体中包含数据域，和左孩子指针还有右孩子指针</li>
<li>n个结点的二叉链表中，含有n+1个空链域，这些空链域可以在后续利用起来</li>
<li><strong>二叉树的遍历</strong></li>
<li>先序遍历，中序遍历，后序遍历</li>
<li>用递归实现</li>
<li>层次遍历用队列</li>
</ul>
<div class="code-container" code-lang="Plaintext"><div class="codebox"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">层次遍历</span><br><span class="line">先给一个要遍历的树</span><br><span class="line">搞个队列让他先进先出，也就是完成层次遍历这个操作</span><br><span class="line">所以先初始化队列</span><br><span class="line">然后搞一个树的指针，类型和刚才那树一致</span><br><span class="line"></span><br><span class="line">先进行入队操作，把树的根节点传进队列，只要这个队列不为空就进行循环</span><br><span class="line">先出队，然后那个指针指向刚出队的那个地址，visit p</span><br><span class="line">访问这个节点，比如打印这个节点。</span><br><span class="line">只要这个节点还有左右孩子，左右孩子就分别入队，</span><br><span class="line">然后继续循环</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 1. 二叉树节点定义 </span><br><span class="line">typedef struct BiTNode &#123; </span><br><span class="line">char data; // 节点数据（以字符为例） </span><br><span class="line">struct BiTNode *lchild; // 左孩子指针 </span><br><span class="line">struct BiTNode *rchild; // 右孩子指针</span><br><span class="line"> &#125; BiTNode, *BiTree; </span><br><span class="line"> // BiTree 是指向节点的指针类型 </span><br><span class="line"> </span><br><span class="line"> // 2. 队列的节点定义（队列中存储的是“二叉树节点的指针”） </span><br><span class="line"> typedef struct QueueNode &#123; </span><br><span class="line"> BiTree data; // 数据域：存储二叉树节点的指针</span><br><span class="line">  struct QueueNode *next; // 指针域：指向下一个队列节点 </span><br><span class="line">  &#125; QueueNode, *QueuePtr;</span><br><span class="line">  </span><br><span class="line">   // 3. 队列的整体结构（含队头、队尾指针） </span><br><span class="line">   typedef struct &#123; </span><br><span class="line">   QueuePtr front; // 队头指针（指向队列第一个节点） </span><br><span class="line">   QueuePtr rear; // 队尾指针（指向队列最后一个节点） </span><br><span class="line">   &#125; LinkQueue;</span><br><span class="line">  </span><br><span class="line">  // 1. 初始化队列（创建空队列） </span><br><span class="line">  void InitQueue(LinkQueue *Q) &#123; </span><br><span class="line">  Q-&gt;front = Q-&gt;rear = (QueuePtr)malloc(sizeof(QueueNode)); // 创建头节点 </span><br><span class="line">  Q-&gt;front-&gt;next = NULL; // 头节点的next置空（空队列） </span><br><span class="line">  &#125; </span><br><span class="line">  </span><br><span class="line">  // 2. 判断队列是否为空（空返回1，非空返回0） </span><br><span class="line">  int IsEmpty(LinkQueue Q) &#123; </span><br><span class="line">  if (Q.front == Q.rear) </span><br><span class="line">  return 1; // 队头队尾指向同一头节点，为空</span><br><span class="line">   else return 0; &#125; </span><br><span class="line">   // 3. 入队操作（将二叉树节点指针x加入队列） </span><br><span class="line">   void EnQueue(LinkQueue *Q, BiTree x) &#123; </span><br><span class="line">   QueuePtr s = (QueuePtr)malloc(sizeof(QueueNode)); // 创建新队列节点 </span><br><span class="line">   s-&gt;data = x; // 新节点的数据域存二叉树节点指针x </span><br><span class="line">   s-&gt;next = NULL; // 新节点的next置空 </span><br><span class="line">   Q-&gt;rear-&gt;next = s; // 队尾节点的next指向新节点 </span><br><span class="line">   Q-&gt;rear = s; // 队尾指针后移到新节点 &#125; </span><br><span class="line">   </span><br><span class="line">   // 4. 出队操作（将队头元素取出，赋值给p） </span><br><span class="line">   void DeQueue(LinkQueue *Q, BiTree *p) &#123; </span><br><span class="line">   if (IsEmpty(*Q)) return; // 队空则不操作 </span><br><span class="line">   QueuePtr s = Q-&gt;front-&gt;next; // s指向真正的队头节点（头节点的下一个） </span><br><span class="line">   *p = s-&gt;data; // 关键：将队头节点存储的二叉树指针赋值给p（外部的p被赋值） </span><br><span class="line">   Q-&gt;front-&gt;next = s-&gt;next; // 头节点的next跳过s，指向s的下一个节点 </span><br><span class="line">   // 如果出队的是最后一个节点，队尾指针要回到头节点 </span><br><span class="line">   if (Q-&gt;rear == s) Q-&gt;rear = Q-&gt;front; </span><br><span class="line">   free(s); // 释放出队的队列节点 </span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">  // 访问节点（打印数据） </span><br><span class="line">  void visit(BiTNode *node) &#123; </span><br><span class="line">  printf(&quot;%c &quot;, node-&gt;data); &#125; // 层次遍历函数 </span><br><span class="line">  void LevelOrder(BiTree T) &#123; </span><br><span class="line">  LinkQueue Q; // 定义队列 </span><br><span class="line">  InitQueue(&amp;Q); // 初始化队列（创建头节点） </span><br><span class="line">  BiTree p; // 定义p：用来接收出队的二叉树节点指针（此时p未赋值） </span><br><span class="line">  // 根节点非空则先入队 </span><br><span class="line">  if (T != NULL) &#123; EnQueue(&amp;Q, T); </span><br><span class="line">  // 根节点入队（队列中存储的是T的地址） &#125; </span><br><span class="line">  // 队列非空时循环 </span><br><span class="line">  while (!IsEmpty(Q)) &#123; </span><br><span class="line">  DeQueue(&amp;Q, &amp;p); // 关键：出队，将队头存储的二叉树节点指针赋值给p </span><br><span class="line">  // 此时p就指向了出队的二叉树节点（比如第一次循环p指向根节点） </span><br><span class="line">  visit(p); // 访问p指向的节点 </span><br><span class="line">  // 若p有左孩子，左孩子入队 </span><br><span class="line">  if (p-&gt;lchild != NULL) &#123; </span><br><span class="line">  EnQueue(&amp;Q, p-&gt;lchild); </span><br><span class="line">  &#125; </span><br><span class="line">  // 若p有右孩子，右孩子入队 </span><br><span class="line">  if (p-&gt;rchild != NULL) &#123; </span><br><span class="line">  EnQueue(&amp;Q, p-&gt;rchild); &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><div class="code-fold" title="Fold/Open"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M6 9l6 6l6 -6" /></svg></div><div class="code-copy" title="Copy"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"  stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg></div></div></div>
<ul>
<li>由遍历序列构造二叉树</li>
<li>已知中序序列，给出其他任意一种，就可以唯一确认一颗二叉树</li>
<li><strong>线索二叉树</strong></li>
<li>含有n个结点的二叉树中有n+1个空指针，因为每个叶结点都有两个空指针，每个度为1的结点都有一个空指针，再加上叶节点和度为2的结点关系。可以推出来有n+1个空指针</li>
<li>这些空指针拿来放线索就能更方便遍历二叉树，方前驱指针和后继指针</li>
<li>同时需要两个标志位，ltag，0为左孩子，1为前驱结点</li>
<li>线索二叉树的构建其实就是进行一次遍历，对二叉树的线索化递归算法</li>
<li>如果带了头结点，会更方便</li>
<li>树的存储结构<ul>
<li>双亲表示法，伪指针（数组表示）</li>
<li>孩子表示法，用数组表示一个个结点，用链表表示各自的孩子</li>
<li>孩子兄弟表示法，结点，指向结点第一个孩子的指针和指向结点下一个兄弟的指针</li>
</ul>
</li>
<li>树，森林与二叉树的转换</li>
<li><strong>树转换成二叉树</strong>，可以用孩子兄弟表示法，左指针指向第一个孩子，右指针指向它在树中的相邻右兄弟。去掉多余连接线。然后顺时针旋转45度</li>
<li><strong>森林转二叉树</strong><ul>
<li>将森林中每棵树转换成二叉树</li>
<li>然后每棵树的根视为兄弟关系，根之间加一根连线</li>
<li>顺时针旋转45度</li>
</ul>
</li>
<li><strong>二叉树转换为森林</strong></li>
<li>反过来就是。</li>
<li>树和森林的遍历好像没看出太大差别，具体题目里看看</li>
<li><strong>哈夫曼树</strong></li>
<li>结点的带权路径长度和树的带权路径长度（所有叶节点的带权路径长度之和）</li>
<li>哈夫曼树是带权路径长度最小的二叉树，也是最优二叉树</li>
<li>哈夫曼树的构造要学会</li>
<li>哈夫曼树构造过程中新建了n-1个结点，所以哈夫曼树结点总数是2n-1</li>
<li>哈夫曼树不存在度为1的结点</li>
<li>哈夫曼编码，为了避免前缀编码的影响，例如一个字符用二进制表示是10 ，另一个是1010，当放在一整条编码上就很难解读出来，因为后面那个字符里也有10，所以用哈夫曼编码可以解决该问题。假设左分支是0，有分支是1，然后两两组合往上推进（频率低的先组合，因为频率低的要给它设计成长编码，所以在树的底下），最后成树的时候，就可以编码了。</li>
<li>记得算带权路径长度，WPL一定是相同的，因为是最优解</li>
<li><strong>并查集</strong></li>
<li>其实和树的双亲表示法类似，用数组存储，根结点的数组值为-1，其他的数组值都为自己双亲结点的下标</li>
<li>若要成为集合的并，那就是吧一个子集合的根节点的双亲指针只想另一个集合的根</li>
<li>并查集的操作可以看看</li>
<li>并查集的优化，查，要一层层找父节点，也因此，如果遇到深度特别深的，时间复杂度就大了。所以要让它深度最小，在并之前，可以先判断子集成员数量，令成员少的根指向成员多的根。即，小树合并到大树。为此，根结点的绝对值保存集合树中的成员数量。</li>
<li>查也能优化，因为原本一层层找，为了确认这个元素在不在这个集合里，可以在第一次找的时候，就把这个一整条路径都放到根节点下，一眼就能看出这个元素在不在这个树下。</li>
<li>这里的实现要看看。</li>
</ul>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><ul>
<li>线性表可以是空表，数可以是空树，但图不可以是空图，即图中一定要有一个顶点，但是边集可以为空。顶点集不可以。G图，V顶点，E边，G（V，E）</li>
<li>有向图，即E有方向，也称弧。&lt;1,2&gt;   即1到2的方向</li>
<li>无向图，若E为无向边，简称边。（1,2）</li>
<li>简单图，即不存在重复边，不存在顶点指向自己的边</li>
<li>多重图，两点间边数大于一，且又允许顶点通过一条边和自己关联。</li>
<li>无向图全部的顶点的度之和等于边数的两倍。</li>
<li>有向图，分入度和出度，度为入度和出度之和。有向图的全部顶点入度和出度之和相等。且等于边数</li>
<li>顶点与顶点之间的路径上边的数目称为路径长度。若n个顶点，有大于n-1条边，则此图一定有环。</li>
<li><strong>简单路径</strong>，顶点不重复的路径，简单回路，除了第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称为<strong>简单回路</strong>。</li>
<li>距离为两顶点的最短路径，若没有路径，那距离为无穷。</li>
<li><strong>子图</strong>，顶点是主图顶点的子集，边是主图边的子集，但是需要注意，并不是任意一个顶点子集和边子集就能称为子图，因为可能不构成图，需要这条边的两个顶点都在顶点子集中。</li>
<li>如果两个图的顶点是一样的，那么称为子图同时为<strong>生成子图</strong>。即顶点全保留，边随便选。</li>
<li>无向图中，两个顶点路径存在，那么这两顶点就是连通的。如果任意两个顶点都是连通的，那么这个图为<strong>连通图</strong>。无向图中的极大连通子图为<strong>连通分量</strong>。</li>
<li>如果一个图是n个顶点，边数小于n-1条边，那一定不连通。</li>
<li>如果一个图是非连通图，那么最多可以多少条边？这个问题可以理解为，顶点n，先去掉一个顶点，变成完全图（全连接，n-1个顶点，每条都能连接n-2条边，然后由于出现重复的了，所以除以2），然后加上这个顶点就变成非连通图。</li>
<li>注意，<strong>无向图中讨论连通性，有向图中讨论强连通性</strong>。</li>
<li>两个顶点互相有路径，称为强连通，a-&gt;b,b-&gt;a。若有向图中任意一对顶点都是强连通的，那就是强连通图。有向图中极大强连通子图为有向图的强连通分量。</li>
<li>n个顶点，如果是个强连通图，最少需要多少边？n条，变成一个环就行。</li>
<li><strong>生成树</strong>是包含图中所有顶点的极小连通子图，减去一条边就会变成非连通图，加上一条边就会变成回路。非连通图中，连通分量的生成树构成了非连通图的生成森林。</li>
<li>在一个图中，每条边都可以标上具有某种含义的值，为权值，这个是带权图，也称网。路径上所有边的权值之和，称为该路径的带权路径长度。</li>
<li>完全图任意两个顶点之间都存在边。对于无向图是n(n-1)&#x2F;2条边，对于有向图来说是n(n-1)条边为完全图</li>
<li>稠密图，稀疏图，是相对而言的。</li>
<li>有向数，一个顶点入度为0，其余顶点入度均为1的有向图。</li>
</ul>
<h4 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h4><ul>
<li><strong>邻接矩阵法</strong></li>
<li>用一维数组存顶点，用二维数组存储顶点和边邻接关系，无向图两顶点为有边事是1，没有边是0。有向图，有边1，没有边事0或不存在，用无穷符号表示。如果带权图，放权值。</li>
<li>简单应用中，可以直接用二维数组作为邻接矩阵，顶点信息可以忽略。当邻接矩阵表示边是否存在时，EdgeType可用0和1枚举类型。无向图的邻接矩阵是对称矩阵，对规模特大的可以用压缩存储。邻接矩阵表示法的空间复杂度为O($n^2$),n为顶点数。</li>
<li>无向图，邻接矩阵第i行或i列的非零元素个数，就是这个点的度</li>
<li>有向图，第i行是出度，第i列入度</li>
<li>用邻接矩阵，很容易确认顶点之间是否有边相连，但是不好确认有多少条边</li>
<li>稠密图适合用邻接矩阵</li>
<li><strong>邻接矩阵A，$A^n$的元素$A^n$ [i]  [j] 为i到j长度为n的路径长度</strong></li>
<li><strong>邻接表法</strong></li>
<li>顶点和边表头指针用顺序存储，称为顶点表，边表用链式存储</li>
<li>存在两种节点，一种是顶点表节点，一种是边表结点</li>
<li>顶点表结点包括顶点域（存储顶点v）和边表头指针域（指向第一条边的边表节点）</li>
<li>边表节点至少两个域，邻接点域，存储与头结点顶点v邻接的顶点编号，指针域只想下一条边的边表节点</li>
<li>适用于稀疏图</li>
<li>邻接表中给定一个顶点，能找到它所有邻边。而邻接矩阵在找所有领边需要扫描一行。但是若要确定给定俩顶点是否存在边，则在邻接矩阵中立刻能查到。而在邻接表则需要边表中查找另一结点</li>
<li>无向图和有向图的领接表中，找无向图的度和有向图的出度，只要计算邻接表边表节点个数就行。但是对于有向图来说，求它的入度，则需要编译全部邻接表，统计邻接点域为x的边表节点个数</li>
<li>邻接表不唯一，因为链接次序是任意的。</li>
<li><strong>十字链表</strong>（不好理解，但仔细看能看懂）</li>
<li>有向图的链式存储结构</li>
<li>弧结点（弧尾节点编号，弧头结点编号，和弧头结点相同的下一条弧，和弧尾相同的下一条弧，弧信息）和顶点节点（顶点信息，指向该顶点的弧，以该结点为弧尾的第一条弧）</li>
<li>十字链表中，容易找到以v为头的弧，也容易找到v为尾的弧，容易求得顶点的出度与入度，十字链表不是唯一的，但是一个十字链表确定一个图</li>
<li>弧尾就是箭尾，弧头就是箭头</li>
<li><strong>邻接多重表</strong>（有空在回头补补吧，多看两遍就会了，不难，记不住倒是真的）</li>
<li>是无向图的链式存储方式</li>
<li>也是有顶点节点和边结点</li>
<li>图的四种存储方式总结<ul>
<li>空间复杂度需要看看</li>
<li>找相邻边有十字链表和邻接多重表很方便</li>
<li>删除边和顶点，删除边邻接矩阵方便，但是删除顶点需要移动大量数据。领接表两者都不方便，十字链表和邻接多重表都方便</li>
<li>邻接矩阵适合稠密图，邻接表适合稀疏图和其他。十字链表只适合有向图，邻接多重表只能存无向图</li>
<li>邻接矩阵唯一，其他都不唯一</li>
</ul>
</li>
</ul>
<h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><ul>
<li>广度优先搜索（BFS）<ul>
<li>类似于树的层序遍历</li>
<li>入队，队列非空，出队，入队刚才那个结点相邻结点</li>
<li>最坏情况下，空间复杂度O(|V|)</li>
</ul>
</li>
<li>深度优先搜索（DFS  Depth）<ul>
<li>类似于树的先序遍历</li>
<li>一直往下访问，当无法再继续向下访问时，依次退回到最近被访问的顶点。然后继续重复搜索，直到搜完。</li>
</ul>
</li>
</ul>
<h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul>
<li>最小生成树，包含所有顶点并且尽可能边少。砍去一条边变成飞连通图，增加一条边会形成回路</li>
<li>而对于带权图，权值最小的那棵生成树为最小生成树</li>
<li>(先这样吧，后面没心情看了，有机会继续学习)</li>
</ul>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2></div><div class="post-reward"><div class="post-reward-btn" title="赞赏作者"><img src="/assets/images/svg/uc/uc-gift.svg" class="icon noview" alt="Icon"><span>可以请我喝杯阿华田嘛~~~</span></div><div class="post-reward-content"><div class="post-reward-text">谢谢恩人~</div><div class="post-reward-qrcode"><div class="post-reward-qrcode-item"><a href="https://raw.githubusercontent.com/maomaogongzi/blog-images/main/qrcode/Wchat.png" target="_blank"><img class="noview" src="https://raw.githubusercontent.com/maomaogongzi/blog-images/main/qrcode/Wchat.png" alt="QRCode"/></a><span>微信</span></div><div class="post-reward-qrcode-item"><a href="https://raw.githubusercontent.com/maomaogongzi/blog-images/main/qrcode/Alipay.jpg" target="_blank"><img class="noview" src="https://raw.githubusercontent.com/maomaogongzi/blog-images/main/qrcode/Alipay.jpg" alt="QRCode"/></a><span>支付宝</span></div></div><div class="post-reward-list"><a href="/null" target="_blank">致谢名单</a></div></div></div><div class="post-copyright"><div class="post-copyright-info">本作品由 NaTie 于 2025-10-28 20:01:47 发布</div><div class="post-copyright-link"><span>作品地址：<a href="http://example.com/2025/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%97%AE%E9%A2%98/">计算机问题</a></span><button class="copy-text" type="button" data-text="http://example.com/2025/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%97%AE%E9%A2%98/">复制</button></div><div class="post-copyright-detail">除特别声明外，本站作品均采用 <a href='https://creativecommons.org/licenses/by-nc-sa/4.0/' title='Attribution-NonCommercial-ShareAlike' target='_blank'>CC BY-NC-SA 4.0</a> 许可协议，转载请注明来自 <a href='/'>NaTie 's Hexo</a></div><img class="post-copyright-icon noview" src="/assets/images/Hexo-Theme-MEOW.png" alt="Logo"/></div><div class="post-tail-tags"><a class="post-tail-tags-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></div></div><aside id="post-sidebar" status="show"><div id="toc-container"><div class="toc-title"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"><span>目录</span></div><div class="toc-content" id="toc-div"><ol class="toc-list"><li class="toc-list-item toc-list-level-1"><a class="toc-list-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-list-number">1.</span> <span class="toc-list-text">数据结构</span></a><ol class="toc-list-child"><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-list-number">1.1.</span> <span class="toc-list-text">绪论</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-list-number">1.2.</span> <span class="toc-list-text">线性表</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-list-number">1.3.</span> <span class="toc-list-text">栈、队列、数组</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E4%B8%B2%EF%BC%88%E7%AE%97%E6%B3%95%E5%9C%A8%E8%80%83%E7%A0%94%E4%B8%AD%E4%B8%8D%E8%80%83%EF%BC%89"><span class="toc-list-number">1.4.</span> <span class="toc-list-text">串（算法在考研中不考）</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-list-number">1.5.</span> <span class="toc-list-text">树与二叉树</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E5%9B%BE"><span class="toc-list-number">1.6.</span> <span class="toc-list-text">图</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-list-number">1.7.</span> <span class="toc-list-text">查找</span></a></li><li class="toc-list-item toc-list-level-2"><a class="toc-list-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-list-number">1.8.</span> <span class="toc-list-text">排序</span></a></li></ol></li></ol></div></div></aside></div></div><div id="toolbar" hide=""><div id="toolbar-setting-container" hide=""><div class="toolbar-item"><button id="tool-color-mode" title="深色模式" type="button"><img src="/assets/images/svg/ta/ta-moon.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button class="copy-text" id="tool-share" title="分享" type="button" data-text="http://example.com/2025/10/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E9%97%AE%E9%A2%98/"><img src="/assets/images/svg/ta/ta-share.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-plus" title="放大字体" type="button"><img src="/assets/images/svg/ta/ta-text-plus.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-font-size-minus" title="缩小字体" type="button"><img src="/assets/images/svg/ta/ta-text-minus.svg" class="icon noview" alt="Icon"></button></div></div><div class="toolbar-container"><div class="toolbar-item"><button id="tool-setting" title="设置" type="button"><img src="/assets/images/svg/ta/ta-setting.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-toc" title="目录" type="button"><img src="/assets/images/svg/ta/ta-toc.svg" class="icon noview" alt="Icon"></button></div><div class="toolbar-item"><button id="tool-gototop" title="返回顶部" type="button"><img src="/assets/images/svg/ta/ta-up.svg" class="icon noview" alt="Icon"></button></div></div></div><div class="search-overlay"><div class="search-container"><div class="search-header"><div class="search-title"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg>
搜索</div><div class="search-close-btn"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 21a9 9 0 0 0 9 -9a9 9 0 0 0 -9 -9a9 9 0 0 0 -9 9a9 9 0 0 0 9 9z" /><path d="M9 8l6 8" /><path d="M15 8l-6 8" /></svg></div></div><div class="search-input-box"><input id="search-input" type="search" placeholder="请输入关键词进行站内搜索……" value="" maxlength="80"/></div><div class="search-result-container"><div class="search-result-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0" /><path d="M21 21l-6 -6" /></svg></div></div></div></div></main><footer><div class="footer"><div id="footer-copyright">© 2025 - 2026 <span>🐇</span> <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/NaTie">NaTie</a></div><div id="footer-info"><div id="footer-framework">🚀本站由 <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/chanwj/hexo-theme-meow" title="3.1.0" target="_blank">Meow</a> 强力驱动</div><div id="footer-runtime"><span id="runtime" data-startdate="2025-10-14T20:13:24.000Z">🌻已稳定运行.年.月.天</span></div></div><div id="footer-statistic"><span>共撰写7篇文章，全站共15.1k字</span></div><div id="footer-pageview"><div id="container_site_pv"><span>🔥总访问量</span><span id="vercount_value_site_pv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div><div id="container_site_uv"><span>🐈访客人数</span><span id="vercount_value_site_uv"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none"  stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M12 6l0 -3" /><path d="M16.25 7.75l2.15 -2.15" /><path d="M18 12l3 0" /><path d="M16.25 16.25l2.15 2.15" /><path d="M12 18l0 3" /><path d="M7.75 16.25l-2.15 2.15" /><path d="M6 12l-3 0" /><path d="M7.75 7.75l-2.15 -2.15" /></svg></span></div></div></div></footer><div class="scripts"><script>const GLOBALCONFIG = {
  root: '/',
  toolbar: true,
  lazyload_src: '/assets/images/Meow-Loading.webp',
  friends: false,
  codeblock: true,
  share_text: '☕Share From NaTie https://www.zhihu.com/people/NaTie',
  onblur_title: '拿铁喊你回家吃饭~~',
  mouse_click: true,
  notify:{
    enable: true,
    info: '复制成功～转载请标注本文地址',
    f12_info: '开发者模式已打开，请遵循本站版权协议'
  },
  search: {
    enable: true,
    path: 'search.xml',
    local: {
      top_n_per_article: -1,
      preload: false
    }
  },
  encrypt: false,
};
</script><script>if (!localStorage.getItem('color-mode')) {
  localStorage.setItem('color-mode', 'light' || 'light');
}
document.body.setAttribute('data-mode', localStorage.getItem('color-mode'));
</script>
<script src="/js/theme/tools/utils.js"></script>

<script src="/js/plugins/dist/lazyload.min.js"></script>

<script src="/js/plugins/view-image.min.js"></script>
<script src="https://cn.vercount.one/js" defer="defer"></script><script>if (localStorage.getItem('font-size')) {
  document.querySelector('.post').style.fontSize = localStorage.getItem('font-size') + 'px';
}
</script>
<script src="/js/plugins/dist/snackbar.min.js"></script>

<script src="/js/plugins/dist/search.js"></script>

<script src="/js/main.js" type="module"></script>
</div></body></html>